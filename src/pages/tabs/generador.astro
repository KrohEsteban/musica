---
import Layout from '../../layouts/Layout.astro';
import TabAutosplit from '../../components/TabAutosplit.astro';
---

<Layout title="üé∏ Generador de Tabs (Ukelele)">
  <div class="generator-container">
    <h1>üé∏ Generador de Tabs (Ukelele)</h1>
    <p class="hint">Convierte entre notaci√≥n r√°pida y tablatura para ukelele (A‚ÄìE‚ÄìC‚ÄìG).</p>

      <div class="card">
        <p class="hint"><strong>Reglas:</strong></p>
        <ul class="hint">
          <li>Columnas separadas por espacio (cada columna = 1 tiempo).</li>
          <li>Notas: <code>G0</code>, <code>C2</code>, <code>E3</code>, <code>A10</code> &nbsp;|&nbsp; Silencios: <code>G-</code> o <code>-</code> o <code>Gx</code> o <code>Gmute</code>, etc.</li>
          <li>Acordes: unir con <code>+</code>, p.ej. <code>G0+E0</code>, <code>C2+E3+A3</code>.</li>
          <li>Salida en orden <strong>A, E, C, G</strong> con ancho por columna seg√∫n el traste m√°s largo.</li>
          <li><strong>M√∫ltiples l√≠neas:</strong> Cada l√≠nea genera una tab separada.</li>
        </ul>

        <textarea id="input" placeholder="Ej.:&#10;G0 C2 E0 E2 E3 E2 E0&#10;A0 A2 Ax+Ex+Cx+Gx A3 A2 A0&#10;G0+E0 C2+E2 G0+E0"></textarea>

        <div class="row">
          <button id="btn-gen">Generar</button>
          <button id="btn-sample">Cargar ejemplo</button>
        </div>

        <div class="output" id="outbox" hidden>
          <div id="tab-display"></div>
          <div class="toolbar">
            <button id="btn-copy">Copiar</button>
            <button id="btn-download">Descargar .txt</button>
          </div>
        </div>
      </div>

      <!-- Segundo generador: Tablatura a Notaci√≥n R√°pida -->
      <div class="card">
        <h2>üîÑ Tablatura ‚Üí Notaci√≥n R√°pida</h2>
        <p class="hint">Peg√° una tablatura y convertila a notaci√≥n r√°pida.</p>

        <p class="hint"><strong>Formato de entrada:</strong></p>
        <ul class="hint">
          <li>Peg√° la tablatura completa (4 l√≠neas: A, E, C, G)</li>
          <li>Formato: <code>A|-0-2-0-2-3-2-0-|</code></li>
          <li><strong>M√∫ltiples l√≠neas:</strong> Cada tablatura genera una linea de notaci√≥n separada.</li>
        </ul>

        <textarea id="input-tab" placeholder="Peg√° aqu√≠ la tablatura:&#10;A|-------------|&#10;E|----0-2-3-2-0|&#10;C|--2----------|&#10;G|0------------|"></textarea>

        <div class="row">
          <button id="btn-gen-tab">Convertir</button>
          <button id="btn-sample-tab">Cargar ejemplo</button>
        </div>

        <div class="output" id="outbox-tab" hidden>
          <pre id="output-tab"></pre>
          <div class="toolbar">
            <button id="btn-copy-tab">Copiar</button>
            <button id="btn-download-tab">Descargar .txt</button>
          </div>
        </div>
      </div>
  </div>
</Layout>

<style>
  .generator-container {
    margin: 0 auto;
    padding: 0 16px 48px;
  }

  .generator-container h1 {
    font-size: 1.6rem;
    margin: 0 0 8px;
  }

  .generator-container .hint {
    color: #666;
    margin: 0 0 16px;
    font-size: .9rem;
  }

  .card {
    border: 1px solid #e9ecef;
    border-radius: 12px;
    padding: 16px;
    background: #f8f9fa;
    margin: 1rem 0;
  }

  .card textarea {
    width: calc(100% - 24px);
    min-height: 140px;
    resize: vertical;
    border-radius: 10px;
    border: 1px solid #e9ecef;
    background: white;
    color: #333;
    padding: 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    line-height: 1.35;
    box-sizing: border-box;
  }

  /* Estilo espec√≠fico para el textarea del segundo generador (Tablatura ‚Üí Notaci√≥n) */
  #input-tab {
    overflow-x: auto;
  }

  /* Clase para cuando hay contenido */
  #input-tab.has-content {
    white-space: nowrap;
  }

  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin: 12px 0 8px;
  }

  .card button {
    background: transparent;
    color: #333;
    border: 1px solid #e9ecef;
    border-radius: 10px;
    padding: 8px 12px;
    cursor: pointer;
    transition: border-color 0.3s ease;
  }

  .card button:hover {
    border-color: #3498db;
  }

  .output {
    position: relative;
    margin-top: 12px;
    border: 1px solid #e9ecef;
    border-radius: 10px;
    background: white;
    padding: 12px;
  }

  .output pre {
    margin: 0;
    white-space: pre;
    overflow: auto;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    line-height: 1.2;
    color: #333;
    font-size: 0.9rem;
  }

  .toolbar {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 8px;
  }

  .card code {
    background: #f1f3f4;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 2px 6px;
    color: #333;
  }

  .card ul {
    margin: 0 0 12px 1.2rem;
  }

  .card ul li {
    color: #666;
  }

  /* Estilos del componente TabAutosplit */
  .tab-wrap {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 14px;
    line-height: 1.4;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 1rem;
    overflow-x: hidden;
    white-space: pre;
    max-width: 100%;
    margin-bottom: 0.5rem;
  }

  .tab-block {
    display: block;
    margin: 0 0 0 0;
    padding: 0;
    white-space: pre;
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    min-width: fit-content;
  }

  .tab-block + .tab-block {
    margin-top: 0.5rem;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<script>
      // Tipos TypeScript
      type StringName = "A" | "E" | "C" | "G";
      type Token = string;
      type Column = Token[];
      type Line = Column[];
      type TabLine = Record<StringName, string>;
      type Tab = TabLine[];

      // Orden de impresi√≥n (A, E, C, G)
      const ORDER: StringName[] = ["A","E","C","G"];
      const STRINGS = new Set<StringName>(["G","C","E","A"]);

      const $ = (id: string): HTMLElement | null => document.getElementById(id);

      // Primer generador (Notaci√≥n ‚Üí Tablatura)
      const $input = $("input") as HTMLTextAreaElement;
      const $gen = $("btn-gen") as HTMLButtonElement;
      const $sample = $("btn-sample") as HTMLButtonElement;
      const $outbox = $("outbox") as HTMLDivElement;
      const $tabDisplay = $("tab-display") as HTMLDivElement;
      const $copy = $("btn-copy") as HTMLButtonElement;
      const $dl = $("btn-download") as HTMLButtonElement;

      // Variable para almacenar la tablatura original generada
      let originalTabOutput = "";

      // Segundo generador (Tablatura ‚Üí Notaci√≥n)
      const $inputTab = $("input-tab") as HTMLTextAreaElement;
      const $genTab = $("btn-gen-tab") as HTMLButtonElement;
      const $sampleTab = $("btn-sample-tab") as HTMLButtonElement;
      const $outboxTab = $("outbox-tab") as HTMLDivElement;
      const $outTab = $("output-tab") as HTMLPreElement;
      const $copyTab = $("btn-copy-tab") as HTMLButtonElement;
      const $dlTab = $("btn-download-tab") as HTMLButtonElement;

      const SAMPLE = "G0 C2 E0 E2 E3 E2 E0\n\nA0 A2 Ax+Ex+Cx+Gx A3 A2 A0\n\nG0+E0 C2+E2 G0+E0";

      const SAMPLE_TAB = `A|-------------|
E|----0-2-3-2-0|
C|--2----------|
G|0------------|

A|0-2-x-3-2-0|
E|----x------|
C|----x------|
G|----x------|

A|-----|
E|0-2-0|
C|--2--|
G|0---0|`;

      function parseColumns(text: string): Line[] {
        // Dividir por l√≠neas primero
        const lines = text.trim().split('\n');

        return lines.map((line: string): Column[] =>
          line.trim()
            .split(/\s+/)              // separa columnas por espacio
            .filter(Boolean)
            .map((col: string): Token[] => col.split("+")  // acordes con '+'
              .map((tok: string): string => tok.trim())
              .filter(Boolean)
            )
        );
      }

      function colWidth(tokens: Token[]): number {
        let maxLen = 1;
        for (const t of tokens) {
          const m = t.match(/^([GCEA])(.+)$/i);
          if (!m) continue;
          const fret = m[2];
          if (fret !== "-") maxLen = Math.max(maxLen, String(fret).length);
        }
        return maxLen;
      }

      function renderTab(linesOfColumns: Line[]): string {
        const result: string[] = [];

        for (const columns of linesOfColumns) {
          if (columns.length === 0) {
            // L√≠nea vac√≠a
            result.push('');
            continue;
          }

          const lines: Record<StringName, string[]> = {
            A: [],
            E: [],
            C: [],
            G: []
          };

          for (const colTokens of columns) {
            const width = Math.max(1, colWidth(colTokens));
            const cell: Record<StringName, string> = {
              A: "-".repeat(width),
              E: "-".repeat(width),
              C: "-".repeat(width),
              G: "-".repeat(width)
            };

            for (const tok of colTokens) {
              const m = tok.match(/^([GCEA])(.+)$/i);
              if (!m) continue;
              let [, s, fret] = m;
              const stringName = s.toUpperCase() as StringName;
              if (!STRINGS.has(stringName)) continue;
              if (fret === "-") continue;

              const text = String(fret);
              const padLeft = Math.floor((width - text.length) / 2);
              const padRight = width - text.length - padLeft;
              cell[stringName] = "-".repeat(padLeft) + text + "-".repeat(padRight);
            }

            for (const s of ORDER) lines[s].push(cell[s]);
          }

          // Agregar las 4 l√≠neas de esta tab
          result.push(...ORDER.map(s => `${s}|${lines[s].join("-")}|`));
        }

        return result.join("\n");
      }

      // Funciones para el segundo generador (Tablatura ‚Üí Notaci√≥n)
      function parseTab(tabText: string): TabLine[] {
        const lines = tabText.trim().split('\n');
        const tabs: TabLine[] = [];
        let currentTab: Partial<TabLine> = {};

        for (const line of lines) {
          if (line.trim() === '') {
            // L√≠nea vac√≠a - terminar tablatura actual y empezar nueva
            if (Object.keys(currentTab).length > 0) {
              tabs.push(currentTab as TabLine);
              currentTab = {};
            }
            continue;
          }

          const match = line.match(/^([AECG])\|(.+)\|$/);
          if (match) {
            const [, string, content] = match;
            currentTab[string as StringName] = content;
          }
        }

        // Agregar la √∫ltima tablatura si existe
        if (Object.keys(currentTab).length > 0) {
          tabs.push(currentTab as TabLine);
        }

        return tabs;
      }

      function tabToNotation(tabLines: TabLine): string {
        const result: string[] = [];
        const maxLength = Math.max(...Object.values(tabLines).map((line: string) => line.length));

        // Procesar columna por columna
        for (let col = 0; col < maxLength; col++) {
          const column: string[] = [];

          for (const string of ORDER) {
            const line = tabLines[string] || '';
            const char = line[col] || '-';

            if (char !== '-') {
              column.push(`${string}${char}`);
            }
          }

          if (column.length > 0) {
            result.push(column.join('+'));
          }
        }

        return result.join(' ');
      }

      function tabsToNotation(tabs: TabLine[]): string {
        return tabs.map((tab: TabLine) => tabToNotation(tab)).join('\n\n');
      }



      function generateTab(): void {
        if (!$inputTab) return;
        const raw = $inputTab.value;
        if (!raw.trim()) {
          if ($outboxTab) $outboxTab.hidden = true;
          return;
        }

        const tabs = parseTab(raw);
        const output = tabsToNotation(tabs);

        if ($outTab) $outTab.textContent = output;
        if ($outboxTab) $outboxTab.hidden = false;
      }


      function copyOutTab(): void {
        if (!$outTab) return;
        const txt = $outTab.textContent || "";
        if (!txt) return;
        navigator.clipboard.writeText(txt).then(() => {
          if (!$copyTab) return;
          const prev = $copyTab.textContent;
          $copyTab.textContent = "¬°Copiado!";
          setTimeout(() => {
            if ($copyTab) $copyTab.textContent = prev;
          }, 800);
        });
      }

      function downloadOutTab(): void {
        if (!$outTab) return;
        const txt = $outTab.textContent || "";
        if (!txt) return;
        const blob = new Blob([txt], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "ukulele-notation.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      function generate(): void {
        if (!$input) return;
        const raw = $input.value;
        if (!raw.trim()) {
          if ($outbox) $outbox.hidden = true;
          return;
        }

        const cols = parseColumns(raw);
        const output = renderTab(cols);

        // Guardar la tablatura original para copiar/descargar
        originalTabOutput = output;

        // Dividir la tablatura en secciones (cada 4 l√≠neas es una tablatura)
        if ($tabDisplay) {
          const lines = output.split('\n').filter(line => line.trim() !== ''); // Filtrar l√≠neas vac√≠as
          const sections = [];

          // Agrupar l√≠neas en secciones de 4 (A, E, C, G)
          for (let i = 0; i < lines.length; i += 4) {
            const section = lines.slice(i, i + 4);
            if (section.length === 4) {
              sections.push(section.join('\n'));
            }
          }

          // Renderizar cada secci√≥n por separado (inicialmente oculto)
          const sectionsHtml = sections.map(section => `
            <div class="tab-wrap" role="img" aria-label="Tablatura" style="visibility: hidden;">
              <pre class="tab-block" data-tab-lines='${JSON.stringify(section.split('\n'))}'>${section}</pre>
            </div>
          `).join('');

          $tabDisplay.innerHTML = sectionsHtml;

          // Ejecutar el ajuste de TabAutosplit y luego mostrar
          if (typeof adjustTabWidth === 'function') {
            // Usar requestAnimationFrame para ejecutar tan pronto como sea posible
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                adjustTabWidth();

                // Mostrar las tablaturas una vez ajustadas
                const tabWraps = $tabDisplay.querySelectorAll('.tab-wrap');
                tabWraps.forEach(wrap => {
                  (wrap as HTMLElement).style.visibility = 'visible';
                });
              });
            });
          }
        }
        if ($outbox) $outbox.hidden = false;
      }

      function copyOut(): void {
        if (!originalTabOutput) return;
        navigator.clipboard.writeText(originalTabOutput).then(() => {
          if (!$copy) return;
          const prev = $copy.textContent;
          $copy.textContent = "¬°Copiado!";
          setTimeout(() => {
            if ($copy) $copy.textContent = prev;
          }, 800);
        });
      }

      function downloadOut(): void {
        if (!originalTabOutput) return;
        const blob = new Blob([originalTabOutput], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "ukulele-tab.txt";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // Event listeners para el primer generador
      if ($gen) $gen.addEventListener("click", generate);
      if ($sample) $sample.addEventListener("click", () => {
        if ($input) {
          ($input as HTMLTextAreaElement).value = SAMPLE;
          generate();
        }
      });
      if ($copy) $copy.addEventListener("click", copyOut);
      if ($dl) $dl.addEventListener("click", downloadOut);

      // Event listeners para el segundo generador
      if ($genTab) $genTab.addEventListener("click", generateTab);
      if ($sampleTab) $sampleTab.addEventListener("click", () => {
        if ($inputTab) {
          ($inputTab as HTMLTextAreaElement).value = SAMPLE_TAB;
          generateTab();
        }
      });
      if ($copyTab) $copyTab.addEventListener("click", copyOutTab);
      if ($dlTab) $dlTab.addEventListener("click", downloadOutTab);

      // Funci√≥n para manejar white-space din√°micamente en el textarea de tablatura
      function handleTabTextareaWhitespace() {
        if (!$inputTab) return;

        if ($inputTab.value.trim()) {
          // Hay contenido: aplicar nowrap
          $inputTab.classList.add('has-content');
        } else {
          // Sin contenido: permitir wrap para el placeholder
          $inputTab.classList.remove('has-content');
        }
      }

      // Aplicar eventos para manejar el white-space din√°micamente
      if ($inputTab) {
        $inputTab.addEventListener('input', handleTabTextareaWhitespace);
        $inputTab.addEventListener('paste', () => {
          // Usar timeout para que el contenido se procese primero
          setTimeout(handleTabTextareaWhitespace, 10);
        });

        // Verificar estado inicial
        handleTabTextareaWhitespace();
      }

      // Autogenerar si ya hay texto (p.ej. hot-reload)
      if ($input && ($input as HTMLTextAreaElement).value.trim()) generate();
      if ($inputTab && ($inputTab as HTMLTextAreaElement).value.trim()) generateTab();

      // Script de TabAutosplit para divisi√≥n din√°mica
      function findCutIndex(lines: string[], startIdx: number, limitIdx: number): number {
        for (let i = limitIdx; i > startIdx; i--) {
          const allBar = lines.every(l => l[i] === '|');
          if (allBar) return i + 1;
        }
        return limitIdx;
      }

      function splitIntoBlocks(lines: string[], charsPerLine: number, preferBarCuts: boolean = true): string[] {
        const blocks = [];
        const totalLen = lines[0].length;
        let i = 0;

        while (i < totalLen) {
          let target = Math.min(i + charsPerLine, totalLen);

          if (target < totalLen && preferBarCuts) {
            const cut = findCutIndex(lines, i, target);
            target = Math.max(cut, Math.min(target, totalLen));
          }

          const slice = lines.map(l => l.slice(i, target));
          const maxInBlock = Math.max(...slice.map(s => s.length));
          const padded = slice.map(s => s.padEnd(maxInBlock, '-'));
          blocks.push(padded.join('\n'));

          i = target;
          if (i >= totalLen) break;
          if (target === i) i = Math.min(i + 1, totalLen);
        }

        return blocks;
      }

      function adjustTabWidth() {
        const tabBlocks = document.querySelectorAll('.tab-block[data-tab-lines]');

        if (tabBlocks.length === 0) return;

        // Calcular ancho de caracter
        const testEl = document.createElement('span');
        testEl.textContent = 'M';
        testEl.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        testEl.style.fontSize = '14px';
        testEl.style.visibility = 'hidden';
        testEl.style.position = 'absolute';
        testEl.style.top = '-9999px';
        document.body.appendChild(testEl);
        const charWidth = testEl.getBoundingClientRect().width || 8;
        document.body.removeChild(testEl);

        // Calcular caracteres por l√≠nea basado en el ancho del contenedor de la p√°gina
        const mainContainer = document.querySelector('main');
        if (!mainContainer) {
          console.warn('No se encontr√≥ el contenedor main');
          return;
        }

        const containerWidth = mainContainer.getBoundingClientRect().width;
        const padding = 80; // padding del contenedor (aumentado para m√°s margen)

        // Calcular charsPerLine proporcionalmente
        // Base: 85 caracteres para 900px de ancho (reducido para evitar scroll)
        const baseWidth = 900;
        const baseChars = 90;
        const ratio = (containerWidth - padding) / (baseWidth - padding);
        let charsPerLine = Math.floor(baseChars * ratio);

        // L√≠mites razonables
        if (charsPerLine < 20) charsPerLine = 20;
        if (charsPerLine > 200) charsPerLine = 200;

        // Aplicar el ancho a todos los bloques
        tabBlocks.forEach(block => {
          try {
            const tabLinesData = block.getAttribute('data-tab-lines');
            if (!tabLinesData) return;

            const lines = JSON.parse(tabLinesData);

            // Verificar si alguna l√≠nea excede el ancho
            const maxLineLength = Math.max(...lines.map((line: string) => line.length));

            if (maxLineLength <= charsPerLine) {
              // No necesita divisi√≥n, mostrar como est√°
              block.textContent = lines.join('\n');
              return;
            }

            // Dividir las l√≠neas en bloques
            const newBlocks = splitIntoBlocks(lines, charsPerLine, true);

            // Reemplazar el contenido del bloque con los nuevos bloques
            block.innerHTML = newBlocks.map(blockContent =>
              `<div class="tab-block">${blockContent}</div>`
            ).join('\n');
          } catch (error) {
            console.error('Error procesando bloque de tablatura:', error);
          }
        });
      }

      function initTabWidth() {
        try {
          adjustTabWidth();
        } catch (error) {
          console.error('‚ùå Error en ajuste de ancho:', error);
        }
      }

      // Ejecutar cuando el DOM est√© listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initTabWidth);
      } else {
        setTimeout(initTabWidth, 100);
      }

      // Reajustar en resize con debounce
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(initTabWidth, 150);
      });
</script>
